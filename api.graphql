### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  token: String
  user: User
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Language {
  code: String!
  createdAt: DateTime!
  index: Int!
  name: String!
  projects(cursor: ProjectWhereUniqueInput, skip: Int, take: Int): [Project!]!
  rtl: Boolean!
  slug: String
  translations(cursor: LanguagesOnTranslationsWhereUniqueInput, skip: Int, take: Int): [LanguagesOnTranslations!]!
  updatedAt: DateTime!
}

input LanguageCreateInput {
  code: String!
  createdAt: DateTime
  index: Int
  name: String!
  projects: ProjectCreateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String
  translations: LanguagesOnTranslationsCreateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageCreateManyWithoutProjectsInput {
  connect: [LanguageWhereUniqueInput!]
  create: [LanguageCreateWithoutProjectsInput!]
}

input LanguageCreateOneWithoutTranslationsInput {
  connect: LanguageWhereUniqueInput
  create: LanguageCreateWithoutTranslationsInput
}

input LanguageCreateWithoutProjectsInput {
  code: String!
  createdAt: DateTime
  index: Int
  name: String!
  rtl: Boolean
  slug: String
  translations: LanguagesOnTranslationsCreateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageCreateWithoutTranslationsInput {
  code: String!
  createdAt: DateTime
  index: Int
  name: String!
  projects: ProjectCreateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String
  updatedAt: DateTime
}

input LanguageListRelationFilter {
  every: LanguageWhereInput
  none: LanguageWhereInput
  some: LanguageWhereInput
}

input LanguageOrderByInput {
  code: SortOrder
  createdAt: SortOrder
  index: SortOrder
  name: SortOrder
  rtl: SortOrder
  slug: SortOrder
  updatedAt: SortOrder
}

input LanguageScalarWhereInput {
  AND: [LanguageScalarWhereInput!]
  code: StringFilter
  createdAt: DateTimeFilter
  index: IntFilter
  name: StringFilter
  NOT: [LanguageScalarWhereInput!]
  OR: [LanguageScalarWhereInput!]
  rtl: BoolFilter
  slug: StringNullableFilter
  updatedAt: DateTimeFilter
}

type LanguagesOnTranslations {
  language: Language!
  translation: Translation!
  value: String!
}

input LanguagesOnTranslationsCreateInput {
  language: LanguageCreateOneWithoutTranslationsInput!
  translation: TranslationCreateOneWithoutLanguagesInput!
  value: String!
}

input LanguagesOnTranslationsCreateManyWithoutLanguageInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutLanguageInput!]
}

input LanguagesOnTranslationsCreateManyWithoutTranslationInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutTranslationInput!]
}

input LanguagesOnTranslationsCreateWithoutLanguageInput {
  translation: TranslationCreateOneWithoutLanguagesInput!
  value: String!
}

input LanguagesOnTranslationsCreateWithoutTranslationInput {
  language: LanguageCreateOneWithoutTranslationsInput!
  value: String!
}

input LanguagesOnTranslationsListRelationFilter {
  every: LanguagesOnTranslationsWhereInput
  none: LanguagesOnTranslationsWhereInput
  some: LanguagesOnTranslationsWhereInput
}

input LanguagesOnTranslationsOrderByInput {
  languageCode: SortOrder
  translationId: SortOrder
  value: SortOrder
}

input LanguagesOnTranslationsScalarWhereInput {
  AND: [LanguagesOnTranslationsScalarWhereInput!]
  languageCode: StringFilter
  NOT: [LanguagesOnTranslationsScalarWhereInput!]
  OR: [LanguagesOnTranslationsScalarWhereInput!]
  translationId: IntFilter
  value: StringFilter
}

input LanguagesOnTranslationsUpdateInput {
  language: LanguageUpdateOneRequiredWithoutTranslationsInput
  translation: TranslationUpdateOneRequiredWithoutLanguagesInput
  value: String
}

input LanguagesOnTranslationsUpdateManyDataInput {
  value: String
}

input LanguagesOnTranslationsUpdateManyWithoutLanguageInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutLanguageInput!]
  delete: [LanguagesOnTranslationsWhereUniqueInput!]
  deleteMany: [LanguagesOnTranslationsScalarWhereInput!]
  disconnect: [LanguagesOnTranslationsWhereUniqueInput!]
  set: [LanguagesOnTranslationsWhereUniqueInput!]
  update: [LanguagesOnTranslationsUpdateWithWhereUniqueWithoutLanguageInput!]
  updateMany: [LanguagesOnTranslationsUpdateManyWithWhereNestedInput!]
  upsert: [LanguagesOnTranslationsUpsertWithWhereUniqueWithoutLanguageInput!]
}

input LanguagesOnTranslationsUpdateManyWithoutTranslationInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutTranslationInput!]
  delete: [LanguagesOnTranslationsWhereUniqueInput!]
  deleteMany: [LanguagesOnTranslationsScalarWhereInput!]
  disconnect: [LanguagesOnTranslationsWhereUniqueInput!]
  set: [LanguagesOnTranslationsWhereUniqueInput!]
  update: [LanguagesOnTranslationsUpdateWithWhereUniqueWithoutTranslationInput!]
  updateMany: [LanguagesOnTranslationsUpdateManyWithWhereNestedInput!]
  upsert: [LanguagesOnTranslationsUpsertWithWhereUniqueWithoutTranslationInput!]
}

input LanguagesOnTranslationsUpdateManyWithWhereNestedInput {
  data: LanguagesOnTranslationsUpdateManyDataInput!
  where: LanguagesOnTranslationsScalarWhereInput!
}

input LanguagesOnTranslationsUpdateWithoutLanguageDataInput {
  translation: TranslationUpdateOneRequiredWithoutLanguagesInput
  value: String
}

input LanguagesOnTranslationsUpdateWithoutTranslationDataInput {
  language: LanguageUpdateOneRequiredWithoutTranslationsInput
  value: String
}

input LanguagesOnTranslationsUpdateWithWhereUniqueWithoutLanguageInput {
  data: LanguagesOnTranslationsUpdateWithoutLanguageDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsUpdateWithWhereUniqueWithoutTranslationInput {
  data: LanguagesOnTranslationsUpdateWithoutTranslationDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsUpsertWithWhereUniqueWithoutLanguageInput {
  create: LanguagesOnTranslationsCreateWithoutLanguageInput!
  update: LanguagesOnTranslationsUpdateWithoutLanguageDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsUpsertWithWhereUniqueWithoutTranslationInput {
  create: LanguagesOnTranslationsCreateWithoutTranslationInput!
  update: LanguagesOnTranslationsUpdateWithoutTranslationDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsWhereInput {
  AND: [LanguagesOnTranslationsWhereInput!]
  language: LanguageWhereInput
  languageCode: StringFilter
  NOT: [LanguagesOnTranslationsWhereInput!]
  OR: [LanguagesOnTranslationsWhereInput!]
  translation: TranslationWhereInput
  translationId: IntFilter
  value: StringFilter
}

input LanguagesOnTranslationsWhereUniqueInput {
  translationId_languageCode: TranslationIdLanguageCodeCompoundUniqueInput
}

input LanguageUpdateInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  projects: ProjectUpdateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String
  translations: LanguagesOnTranslationsUpdateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageUpdateManyDataInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  rtl: Boolean
  slug: String
  updatedAt: DateTime
}

input LanguageUpdateManyWithoutProjectsInput {
  connect: [LanguageWhereUniqueInput!]
  create: [LanguageCreateWithoutProjectsInput!]
  delete: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  disconnect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutProjectsInput!]
  updateMany: [LanguageUpdateManyWithWhereNestedInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutProjectsInput!]
}

input LanguageUpdateManyWithWhereNestedInput {
  data: LanguageUpdateManyDataInput!
  where: LanguageScalarWhereInput!
}

input LanguageUpdateOneRequiredWithoutTranslationsInput {
  connect: LanguageWhereUniqueInput
  create: LanguageCreateWithoutTranslationsInput
  update: LanguageUpdateWithoutTranslationsDataInput
  upsert: LanguageUpsertWithoutTranslationsInput
}

input LanguageUpdateWithoutProjectsDataInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  rtl: Boolean
  slug: String
  translations: LanguagesOnTranslationsUpdateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageUpdateWithoutTranslationsDataInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  projects: ProjectUpdateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String
  updatedAt: DateTime
}

input LanguageUpdateWithWhereUniqueWithoutProjectsInput {
  data: LanguageUpdateWithoutProjectsDataInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpsertWithoutTranslationsInput {
  create: LanguageCreateWithoutTranslationsInput!
  update: LanguageUpdateWithoutTranslationsDataInput!
}

input LanguageUpsertWithWhereUniqueWithoutProjectsInput {
  create: LanguageCreateWithoutProjectsInput!
  update: LanguageUpdateWithoutProjectsDataInput!
  where: LanguageWhereUniqueInput!
}

input LanguageWhereInput {
  AND: [LanguageWhereInput!]
  code: StringFilter
  createdAt: DateTimeFilter
  index: IntFilter
  name: StringFilter
  NOT: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  projects: ProjectListRelationFilter
  rtl: BoolFilter
  slug: StringNullableFilter
  translations: LanguagesOnTranslationsListRelationFilter
  updatedAt: DateTimeFilter
}

input LanguageWhereUniqueInput {
  code: String
  name: String
  slug: String
}

type Mutation {
  createOneLanguage(data: LanguageCreateInput!): Language!
  createOneLanguagesOnTranslations(data: LanguagesOnTranslationsCreateInput!): LanguagesOnTranslations!
  createOneProject(data: ProjectCreateInput!): Project!
  createOneTranslation(data: TranslationCreateInput!): Translation!
  createOneUser(data: UserCreateInput!): User!
  createOneView(data: ViewCreateInput!): View!
  deleteOneLanguage(where: LanguageWhereUniqueInput!): Language
  deleteOneLanguagesOnTranslations(where: LanguagesOnTranslationsWhereUniqueInput!): LanguagesOnTranslations
  deleteOneProject(where: ProjectWhereUniqueInput!): Project
  deleteOneTranslation(where: TranslationWhereUniqueInput!): Translation
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneView(where: ViewWhereUniqueInput!): View
  login(email: String!, password: String!): AuthPayload
  updateOneLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateOneLanguagesOnTranslations(data: LanguagesOnTranslationsUpdateInput!, where: LanguagesOnTranslationsWhereUniqueInput!): LanguagesOnTranslations
  updateOneProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateOneTranslation(data: TranslationUpdateInput!, where: TranslationWhereUniqueInput!): Translation
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneView(data: ViewUpdateInput!, where: ViewWhereUniqueInput!): View
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Project {
  createdAt: DateTime!
  id: Int!
  index: Int!
  languages(cursor: LanguageWhereUniqueInput, skip: Int, take: Int): [Language!]!
  name: String!
  screenshot: String
  slug: String
  updatedAt: DateTime!
  users(cursor: UserWhereUniqueInput, skip: Int, take: Int): [User!]!
  views(cursor: ViewWhereUniqueInput, skip: Int, take: Int): [View!]!
}

input ProjectCreateInput {
  createdAt: DateTime
  index: Int
  languages: LanguageCreateManyWithoutProjectsInput
  name: String!
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserCreateManyWithoutProjectsInput
  views: ViewCreateManyWithoutProjectInput
}

input ProjectCreateManyWithoutLanguagesInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutLanguagesInput!]
}

input ProjectCreateManyWithoutUsersInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUsersInput!]
}

input ProjectCreateOneWithoutViewsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutViewsInput
}

input ProjectCreateWithoutLanguagesInput {
  createdAt: DateTime
  index: Int
  name: String!
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserCreateManyWithoutProjectsInput
  views: ViewCreateManyWithoutProjectInput
}

input ProjectCreateWithoutUsersInput {
  createdAt: DateTime
  index: Int
  languages: LanguageCreateManyWithoutProjectsInput
  name: String!
  screenshot: String
  slug: String
  updatedAt: DateTime
  views: ViewCreateManyWithoutProjectInput
}

input ProjectCreateWithoutViewsInput {
  createdAt: DateTime
  index: Int
  languages: LanguageCreateManyWithoutProjectsInput
  name: String!
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserCreateManyWithoutProjectsInput
}

input ProjectListRelationFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  name: StringFilter
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  screenshot: StringNullableFilter
  slug: StringNullableFilter
  updatedAt: DateTimeFilter
}

input ProjectUpdateInput {
  createdAt: DateTime
  index: Int
  languages: LanguageUpdateManyWithoutProjectsInput
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutProjectsInput
  views: ViewUpdateManyWithoutProjectInput
}

input ProjectUpdateManyDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
}

input ProjectUpdateManyWithoutLanguagesInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutLanguagesInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutLanguagesInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutLanguagesInput!]
}

input ProjectUpdateManyWithoutUsersInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUsersInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutUsersInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  data: ProjectUpdateManyDataInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateOneRequiredWithoutViewsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutViewsInput
  update: ProjectUpdateWithoutViewsDataInput
  upsert: ProjectUpsertWithoutViewsInput
}

input ProjectUpdateWithoutLanguagesDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutProjectsInput
  views: ViewUpdateManyWithoutProjectInput
}

input ProjectUpdateWithoutUsersDataInput {
  createdAt: DateTime
  index: Int
  languages: LanguageUpdateManyWithoutProjectsInput
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  views: ViewUpdateManyWithoutProjectInput
}

input ProjectUpdateWithoutViewsDataInput {
  createdAt: DateTime
  index: Int
  languages: LanguageUpdateManyWithoutProjectsInput
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutProjectsInput
}

input ProjectUpdateWithWhereUniqueWithoutLanguagesInput {
  data: ProjectUpdateWithoutLanguagesDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithWhereUniqueWithoutUsersInput {
  data: ProjectUpdateWithoutUsersDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutViewsInput {
  create: ProjectCreateWithoutViewsInput!
  update: ProjectUpdateWithoutViewsDataInput!
}

input ProjectUpsertWithWhereUniqueWithoutLanguagesInput {
  create: ProjectCreateWithoutLanguagesInput!
  update: ProjectUpdateWithoutLanguagesDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithWhereUniqueWithoutUsersInput {
  create: ProjectCreateWithoutUsersInput!
  update: ProjectUpdateWithoutUsersDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  languages: LanguageListRelationFilter
  name: StringFilter
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  screenshot: StringNullableFilter
  slug: StringNullableFilter
  updatedAt: DateTimeFilter
  users: UserListRelationFilter
  views: ViewListRelationFilter
}

input ProjectWhereUniqueInput {
  id: Int
  name: String
  slug: String
}

type Query {
  language(where: LanguageWhereUniqueInput!): Language
  languages(cursor: LanguageWhereUniqueInput, orderBy: [LanguageOrderByInput!], skip: Int, take: Int, where: LanguageWhereInput): [Language!]!
  languagesOnTranslations(cursor: LanguagesOnTranslationsWhereUniqueInput, orderBy: [LanguagesOnTranslationsOrderByInput!], skip: Int, take: Int): [LanguagesOnTranslations!]!
  project(where: ProjectWhereUniqueInput!): Project
  projects(cursor: ProjectWhereUniqueInput, skip: Int, take: Int): [Project!]!
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(cursor: TranslationWhereUniqueInput, orderBy: [TranslationOrderByInput!], skip: Int, take: Int): [Translation!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, skip: Int, take: Int): [User!]!
  view(where: ViewWhereUniqueInput!): View
  views(cursor: ViewWhereUniqueInput, skip: Int, take: Int, where: ViewWhereInput): [View!]!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Translation {
  createdAt: DateTime!
  id: Int!
  index: Int!
  key: String!
  label: String
  languages(cursor: LanguagesOnTranslationsWhereUniqueInput, skip: Int, take: Int): [LanguagesOnTranslations!]!
  updatedAt: DateTime!
  view: View!
  x: Float
  y: Float
}

input TranslationCreateInput {
  createdAt: DateTime
  index: Int
  key: String!
  label: String
  languages: LanguagesOnTranslationsCreateManyWithoutTranslationInput
  updatedAt: DateTime
  view: ViewCreateOneWithoutTranslationInput!
  x: Float
  y: Float
}

input TranslationCreateManyWithoutViewInput {
  connect: [TranslationWhereUniqueInput!]
  create: [TranslationCreateWithoutViewInput!]
}

input TranslationCreateOneWithoutLanguagesInput {
  connect: TranslationWhereUniqueInput
  create: TranslationCreateWithoutLanguagesInput
}

input TranslationCreateWithoutLanguagesInput {
  createdAt: DateTime
  index: Int
  key: String!
  label: String
  updatedAt: DateTime
  view: ViewCreateOneWithoutTranslationInput!
  x: Float
  y: Float
}

input TranslationCreateWithoutViewInput {
  createdAt: DateTime
  index: Int
  key: String!
  label: String
  languages: LanguagesOnTranslationsCreateManyWithoutTranslationInput
  updatedAt: DateTime
  x: Float
  y: Float
}

input TranslationIdLanguageCodeCompoundUniqueInput {
  languageCode: String!
  translationId: Int!
}

input TranslationListRelationFilter {
  every: TranslationWhereInput
  none: TranslationWhereInput
  some: TranslationWhereInput
}

input TranslationOrderByInput {
  createdAt: SortOrder
  id: SortOrder
  index: SortOrder
  key: SortOrder
  label: SortOrder
  updatedAt: SortOrder
  viewId: SortOrder
  x: SortOrder
  y: SortOrder
}

input TranslationScalarWhereInput {
  AND: [TranslationScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  key: StringFilter
  label: StringNullableFilter
  NOT: [TranslationScalarWhereInput!]
  OR: [TranslationScalarWhereInput!]
  updatedAt: DateTimeFilter
  viewId: IntFilter
  x: FloatNullableFilter
  y: FloatNullableFilter
}

input TranslationUpdateInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  languages: LanguagesOnTranslationsUpdateManyWithoutTranslationInput
  updatedAt: DateTime
  view: ViewUpdateOneRequiredWithoutTranslationInput
  x: Float
  y: Float
}

input TranslationUpdateManyDataInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  updatedAt: DateTime
  x: Float
  y: Float
}

input TranslationUpdateManyWithoutViewInput {
  connect: [TranslationWhereUniqueInput!]
  create: [TranslationCreateWithoutViewInput!]
  delete: [TranslationWhereUniqueInput!]
  deleteMany: [TranslationScalarWhereInput!]
  disconnect: [TranslationWhereUniqueInput!]
  set: [TranslationWhereUniqueInput!]
  update: [TranslationUpdateWithWhereUniqueWithoutViewInput!]
  updateMany: [TranslationUpdateManyWithWhereNestedInput!]
  upsert: [TranslationUpsertWithWhereUniqueWithoutViewInput!]
}

input TranslationUpdateManyWithWhereNestedInput {
  data: TranslationUpdateManyDataInput!
  where: TranslationScalarWhereInput!
}

input TranslationUpdateOneRequiredWithoutLanguagesInput {
  connect: TranslationWhereUniqueInput
  create: TranslationCreateWithoutLanguagesInput
  update: TranslationUpdateWithoutLanguagesDataInput
  upsert: TranslationUpsertWithoutLanguagesInput
}

input TranslationUpdateWithoutLanguagesDataInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  updatedAt: DateTime
  view: ViewUpdateOneRequiredWithoutTranslationInput
  x: Float
  y: Float
}

input TranslationUpdateWithoutViewDataInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  languages: LanguagesOnTranslationsUpdateManyWithoutTranslationInput
  updatedAt: DateTime
  x: Float
  y: Float
}

input TranslationUpdateWithWhereUniqueWithoutViewInput {
  data: TranslationUpdateWithoutViewDataInput!
  where: TranslationWhereUniqueInput!
}

input TranslationUpsertWithoutLanguagesInput {
  create: TranslationCreateWithoutLanguagesInput!
  update: TranslationUpdateWithoutLanguagesDataInput!
}

input TranslationUpsertWithWhereUniqueWithoutViewInput {
  create: TranslationCreateWithoutViewInput!
  update: TranslationUpdateWithoutViewDataInput!
  where: TranslationWhereUniqueInput!
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  key: StringFilter
  label: StringNullableFilter
  languages: LanguagesOnTranslationsListRelationFilter
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  updatedAt: DateTimeFilter
  view: ViewWhereInput
  viewId: IntFilter
  x: FloatNullableFilter
  y: FloatNullableFilter
}

input TranslationWhereUniqueInput {
  id: Int
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  projects(cursor: ProjectWhereUniqueInput, skip: Int, take: Int): [Project!]!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  projects: ProjectCreateManyWithoutUsersInput
  updatedAt: DateTime
}

input UserCreateManyWithoutProjectsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutProjectsInput!]
}

input UserCreateWithoutProjectsInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  updatedAt: DateTime
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  updatedAt: DateTimeFilter
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  projects: ProjectUpdateManyWithoutUsersInput
  updatedAt: DateTime
}

input UserUpdateManyDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpdateManyWithoutProjectsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutProjectsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutProjectsInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutProjectsInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutProjectsDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpdateWithWhereUniqueWithoutProjectsInput {
  data: UserUpdateWithoutProjectsDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  update: UserUpdateWithoutProjectsDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  projects: ProjectListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}

type View {
  createdAt: DateTime!
  id: Int!
  index: Int!
  name: String!
  project: Project!
  screenshot: String
  slug: String
  translation(cursor: TranslationWhereUniqueInput, skip: Int, take: Int): [Translation!]!
  updatedAt: DateTime!
}

input ViewCreateInput {
  createdAt: DateTime
  index: Int
  name: String!
  project: ProjectCreateOneWithoutViewsInput!
  screenshot: String
  slug: String
  translation: TranslationCreateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewCreateManyWithoutProjectInput {
  connect: [ViewWhereUniqueInput!]
  create: [ViewCreateWithoutProjectInput!]
}

input ViewCreateOneWithoutTranslationInput {
  connect: ViewWhereUniqueInput
  create: ViewCreateWithoutTranslationInput
}

input ViewCreateWithoutProjectInput {
  createdAt: DateTime
  index: Int
  name: String!
  screenshot: String
  slug: String
  translation: TranslationCreateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewCreateWithoutTranslationInput {
  createdAt: DateTime
  index: Int
  name: String!
  project: ProjectCreateOneWithoutViewsInput!
  screenshot: String
  slug: String
  updatedAt: DateTime
}

input ViewListRelationFilter {
  every: ViewWhereInput
  none: ViewWhereInput
  some: ViewWhereInput
}

input ViewScalarWhereInput {
  AND: [ViewScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  name: StringFilter
  NOT: [ViewScalarWhereInput!]
  OR: [ViewScalarWhereInput!]
  projectId: IntFilter
  screenshot: StringNullableFilter
  slug: StringNullableFilter
  updatedAt: DateTimeFilter
}

input ViewUpdateInput {
  createdAt: DateTime
  index: Int
  name: String
  project: ProjectUpdateOneRequiredWithoutViewsInput
  screenshot: String
  slug: String
  translation: TranslationUpdateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewUpdateManyDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
}

input ViewUpdateManyWithoutProjectInput {
  connect: [ViewWhereUniqueInput!]
  create: [ViewCreateWithoutProjectInput!]
  delete: [ViewWhereUniqueInput!]
  deleteMany: [ViewScalarWhereInput!]
  disconnect: [ViewWhereUniqueInput!]
  set: [ViewWhereUniqueInput!]
  update: [ViewUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [ViewUpdateManyWithWhereNestedInput!]
  upsert: [ViewUpsertWithWhereUniqueWithoutProjectInput!]
}

input ViewUpdateManyWithWhereNestedInput {
  data: ViewUpdateManyDataInput!
  where: ViewScalarWhereInput!
}

input ViewUpdateOneRequiredWithoutTranslationInput {
  connect: ViewWhereUniqueInput
  create: ViewCreateWithoutTranslationInput
  update: ViewUpdateWithoutTranslationDataInput
  upsert: ViewUpsertWithoutTranslationInput
}

input ViewUpdateWithoutProjectDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  translation: TranslationUpdateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewUpdateWithoutTranslationDataInput {
  createdAt: DateTime
  index: Int
  name: String
  project: ProjectUpdateOneRequiredWithoutViewsInput
  screenshot: String
  slug: String
  updatedAt: DateTime
}

input ViewUpdateWithWhereUniqueWithoutProjectInput {
  data: ViewUpdateWithoutProjectDataInput!
  where: ViewWhereUniqueInput!
}

input ViewUpsertWithoutTranslationInput {
  create: ViewCreateWithoutTranslationInput!
  update: ViewUpdateWithoutTranslationDataInput!
}

input ViewUpsertWithWhereUniqueWithoutProjectInput {
  create: ViewCreateWithoutProjectInput!
  update: ViewUpdateWithoutProjectDataInput!
  where: ViewWhereUniqueInput!
}

input ViewWhereInput {
  AND: [ViewWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  name: StringFilter
  NOT: [ViewWhereInput!]
  OR: [ViewWhereInput!]
  project: ProjectWhereInput
  projectId: IntFilter
  screenshot: StringNullableFilter
  slug: StringNullableFilter
  translation: TranslationListRelationFilter
  updatedAt: DateTimeFilter
}

input ViewWhereUniqueInput {
  id: Int
  name: String
  slug: String
}
