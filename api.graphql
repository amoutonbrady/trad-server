### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  token: String
  user: User
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Language {
  code: String!
  createdAt: DateTime!
  id: Int!
  index: Int!
  name: String!
  projects(after: ProjectWhereUniqueInput, before: ProjectWhereUniqueInput, first: Int, last: Int): [Project!]!
  rtl: Boolean!
  slug: String!
  translations(after: LanguagesOnTranslationsWhereUniqueInput, before: LanguagesOnTranslationsWhereUniqueInput, first: Int, last: Int): [LanguagesOnTranslations!]!
  updatedAt: DateTime!
}

input LanguageCreateInput {
  code: String!
  createdAt: DateTime
  index: Int
  name: String!
  projects: ProjectCreateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String!
  translations: LanguagesOnTranslationsCreateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageCreateManyWithoutProjectsInput {
  connect: [LanguageWhereUniqueInput!]
  create: [LanguageCreateWithoutProjectsInput!]
}

input LanguageCreateOneWithoutTranslationsInput {
  connect: LanguageWhereUniqueInput
  create: LanguageCreateWithoutTranslationsInput
}

input LanguageCreateWithoutProjectsInput {
  code: String!
  createdAt: DateTime
  index: Int
  name: String!
  rtl: Boolean
  slug: String!
  translations: LanguagesOnTranslationsCreateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageCreateWithoutTranslationsInput {
  code: String!
  createdAt: DateTime
  index: Int
  name: String!
  projects: ProjectCreateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String!
  updatedAt: DateTime
}

input LanguageFilter {
  every: LanguageWhereInput
  none: LanguageWhereInput
  some: LanguageWhereInput
}

input LanguageScalarWhereInput {
  AND: [LanguageScalarWhereInput!]
  code: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  name: StringFilter
  NOT: [LanguageScalarWhereInput!]
  OR: [LanguageScalarWhereInput!]
  projects: ProjectFilter
  rtl: BooleanFilter
  slug: StringFilter
  translations: LanguagesOnTranslationsFilter
  updatedAt: DateTimeFilter
}

type LanguagesOnTranslations {
  language: Language!
  translation: Translation!
  value: String!
}

input LanguagesOnTranslationsCreateInput {
  language: LanguageCreateOneWithoutTranslationsInput!
  translation: TranslationCreateOneWithoutLanguagesInput!
  value: String!
}

input LanguagesOnTranslationsCreateManyWithoutLanguageInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutLanguageInput!]
}

input LanguagesOnTranslationsCreateManyWithoutTranslationInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutTranslationInput!]
}

input LanguagesOnTranslationsCreateWithoutLanguageInput {
  translation: TranslationCreateOneWithoutLanguagesInput!
  value: String!
}

input LanguagesOnTranslationsCreateWithoutTranslationInput {
  language: LanguageCreateOneWithoutTranslationsInput!
  value: String!
}

input LanguagesOnTranslationsFilter {
  every: LanguagesOnTranslationsWhereInput
  none: LanguagesOnTranslationsWhereInput
  some: LanguagesOnTranslationsWhereInput
}

input LanguagesOnTranslationsScalarWhereInput {
  AND: [LanguagesOnTranslationsScalarWhereInput!]
  languageId: IntFilter
  NOT: [LanguagesOnTranslationsScalarWhereInput!]
  OR: [LanguagesOnTranslationsScalarWhereInput!]
  translationId: IntFilter
  value: StringFilter
}

input LanguagesOnTranslationsUpdateInput {
  language: LanguageUpdateOneRequiredWithoutTranslationsInput
  translation: TranslationUpdateOneRequiredWithoutLanguagesInput
  value: String
}

input LanguagesOnTranslationsUpdateManyDataInput {
  value: String
}

input LanguagesOnTranslationsUpdateManyWithoutLanguageInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutLanguageInput!]
  delete: [LanguagesOnTranslationsWhereUniqueInput!]
  deleteMany: [LanguagesOnTranslationsScalarWhereInput!]
  disconnect: [LanguagesOnTranslationsWhereUniqueInput!]
  set: [LanguagesOnTranslationsWhereUniqueInput!]
  update: [LanguagesOnTranslationsUpdateWithWhereUniqueWithoutLanguageInput!]
  updateMany: [LanguagesOnTranslationsUpdateManyWithWhereNestedInput!]
  upsert: [LanguagesOnTranslationsUpsertWithWhereUniqueWithoutLanguageInput!]
}

input LanguagesOnTranslationsUpdateManyWithoutTranslationInput {
  connect: [LanguagesOnTranslationsWhereUniqueInput!]
  create: [LanguagesOnTranslationsCreateWithoutTranslationInput!]
  delete: [LanguagesOnTranslationsWhereUniqueInput!]
  deleteMany: [LanguagesOnTranslationsScalarWhereInput!]
  disconnect: [LanguagesOnTranslationsWhereUniqueInput!]
  set: [LanguagesOnTranslationsWhereUniqueInput!]
  update: [LanguagesOnTranslationsUpdateWithWhereUniqueWithoutTranslationInput!]
  updateMany: [LanguagesOnTranslationsUpdateManyWithWhereNestedInput!]
  upsert: [LanguagesOnTranslationsUpsertWithWhereUniqueWithoutTranslationInput!]
}

input LanguagesOnTranslationsUpdateManyWithWhereNestedInput {
  data: LanguagesOnTranslationsUpdateManyDataInput!
  where: LanguagesOnTranslationsScalarWhereInput!
}

input LanguagesOnTranslationsUpdateWithoutLanguageDataInput {
  translation: TranslationUpdateOneRequiredWithoutLanguagesInput
  value: String
}

input LanguagesOnTranslationsUpdateWithoutTranslationDataInput {
  language: LanguageUpdateOneRequiredWithoutTranslationsInput
  value: String
}

input LanguagesOnTranslationsUpdateWithWhereUniqueWithoutLanguageInput {
  data: LanguagesOnTranslationsUpdateWithoutLanguageDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsUpdateWithWhereUniqueWithoutTranslationInput {
  data: LanguagesOnTranslationsUpdateWithoutTranslationDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsUpsertWithWhereUniqueWithoutLanguageInput {
  create: LanguagesOnTranslationsCreateWithoutLanguageInput!
  update: LanguagesOnTranslationsUpdateWithoutLanguageDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsUpsertWithWhereUniqueWithoutTranslationInput {
  create: LanguagesOnTranslationsCreateWithoutTranslationInput!
  update: LanguagesOnTranslationsUpdateWithoutTranslationDataInput!
  where: LanguagesOnTranslationsWhereUniqueInput!
}

input LanguagesOnTranslationsWhereInput {
  AND: [LanguagesOnTranslationsWhereInput!]
  language: LanguageWhereInput
  languageId: IntFilter
  NOT: [LanguagesOnTranslationsWhereInput!]
  OR: [LanguagesOnTranslationsWhereInput!]
  translation: TranslationWhereInput
  translationId: IntFilter
  value: StringFilter
}

input LanguagesOnTranslationsWhereUniqueInput {
  translationId_languageId: TranslationIdLanguageIdCompoundUniqueInput
}

input LanguageUpdateInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  projects: ProjectUpdateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String
  translations: LanguagesOnTranslationsUpdateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageUpdateManyDataInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  rtl: Boolean
  slug: String
  updatedAt: DateTime
}

input LanguageUpdateManyWithoutProjectsInput {
  connect: [LanguageWhereUniqueInput!]
  create: [LanguageCreateWithoutProjectsInput!]
  delete: [LanguageWhereUniqueInput!]
  deleteMany: [LanguageScalarWhereInput!]
  disconnect: [LanguageWhereUniqueInput!]
  set: [LanguageWhereUniqueInput!]
  update: [LanguageUpdateWithWhereUniqueWithoutProjectsInput!]
  updateMany: [LanguageUpdateManyWithWhereNestedInput!]
  upsert: [LanguageUpsertWithWhereUniqueWithoutProjectsInput!]
}

input LanguageUpdateManyWithWhereNestedInput {
  data: LanguageUpdateManyDataInput!
  where: LanguageScalarWhereInput!
}

input LanguageUpdateOneRequiredWithoutTranslationsInput {
  connect: LanguageWhereUniqueInput
  create: LanguageCreateWithoutTranslationsInput
  update: LanguageUpdateWithoutTranslationsDataInput
  upsert: LanguageUpsertWithoutTranslationsInput
}

input LanguageUpdateWithoutProjectsDataInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  rtl: Boolean
  slug: String
  translations: LanguagesOnTranslationsUpdateManyWithoutLanguageInput
  updatedAt: DateTime
}

input LanguageUpdateWithoutTranslationsDataInput {
  code: String
  createdAt: DateTime
  index: Int
  name: String
  projects: ProjectUpdateManyWithoutLanguagesInput
  rtl: Boolean
  slug: String
  updatedAt: DateTime
}

input LanguageUpdateWithWhereUniqueWithoutProjectsInput {
  data: LanguageUpdateWithoutProjectsDataInput!
  where: LanguageWhereUniqueInput!
}

input LanguageUpsertWithoutTranslationsInput {
  create: LanguageCreateWithoutTranslationsInput!
  update: LanguageUpdateWithoutTranslationsDataInput!
}

input LanguageUpsertWithWhereUniqueWithoutProjectsInput {
  create: LanguageCreateWithoutProjectsInput!
  update: LanguageUpdateWithoutProjectsDataInput!
  where: LanguageWhereUniqueInput!
}

input LanguageWhereInput {
  AND: [LanguageWhereInput!]
  code: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  name: StringFilter
  NOT: [LanguageWhereInput!]
  OR: [LanguageWhereInput!]
  projects: ProjectFilter
  rtl: BooleanFilter
  slug: StringFilter
  translations: LanguagesOnTranslationsFilter
  updatedAt: DateTimeFilter
}

input LanguageWhereUniqueInput {
  id: Int
}

type Mutation {
  createOneLanguage(data: LanguageCreateInput!): Language!
  createOneLanguagesOnTranslations(data: LanguagesOnTranslationsCreateInput!): LanguagesOnTranslations!
  createOneProject(data: ProjectCreateInput!): Project!
  createOneTranslation(data: TranslationCreateInput!): Translation!
  createOneUser(data: UserCreateInput!): User!
  createOneView(data: ViewCreateInput!): View!
  deleteOneLanguage(where: LanguageWhereUniqueInput!): Language
  deleteOneLanguagesOnTranslations(where: LanguagesOnTranslationsWhereUniqueInput!): LanguagesOnTranslations
  deleteOneProject(where: ProjectWhereUniqueInput!): Project
  deleteOneTranslation(where: TranslationWhereUniqueInput!): Translation
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneView(where: ViewWhereUniqueInput!): View
  login(email: String!, password: String!): AuthPayload
  updateOneLanguage(data: LanguageUpdateInput!, where: LanguageWhereUniqueInput!): Language
  updateOneLanguagesOnTranslations(data: LanguagesOnTranslationsUpdateInput!, where: LanguagesOnTranslationsWhereUniqueInput!): LanguagesOnTranslations
  updateOneProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateOneTranslation(data: TranslationUpdateInput!, where: TranslationWhereUniqueInput!): Translation
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneView(data: ViewUpdateInput!, where: ViewWhereUniqueInput!): View
}

input NullableFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Project {
  createdAt: DateTime!
  id: Int!
  index: Int!
  name: String!
  screenshot: String
  slug: String!
  updatedAt: DateTime!
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  views(after: ViewWhereUniqueInput, before: ViewWhereUniqueInput, first: Int, last: Int): [View!]!
}

input ProjectCreateInput {
  createdAt: DateTime
  index: Int
  languages: LanguageCreateManyWithoutProjectsInput
  name: String!
  screenshot: String
  slug: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutProjectsInput
  views: ViewCreateManyWithoutProjectInput
}

input ProjectCreateManyWithoutLanguagesInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutLanguagesInput!]
}

input ProjectCreateManyWithoutUsersInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUsersInput!]
}

input ProjectCreateOneWithoutViewsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutViewsInput
}

input ProjectCreateWithoutLanguagesInput {
  createdAt: DateTime
  index: Int
  name: String!
  screenshot: String
  slug: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutProjectsInput
  views: ViewCreateManyWithoutProjectInput
}

input ProjectCreateWithoutUsersInput {
  createdAt: DateTime
  index: Int
  languages: LanguageCreateManyWithoutProjectsInput
  name: String!
  screenshot: String
  slug: String!
  updatedAt: DateTime
  views: ViewCreateManyWithoutProjectInput
}

input ProjectCreateWithoutViewsInput {
  createdAt: DateTime
  index: Int
  languages: LanguageCreateManyWithoutProjectsInput
  name: String!
  screenshot: String
  slug: String!
  updatedAt: DateTime
  users: UserCreateManyWithoutProjectsInput
}

input ProjectFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  languages: LanguageFilter
  name: StringFilter
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  screenshot: NullableStringFilter
  slug: StringFilter
  updatedAt: DateTimeFilter
  users: UserFilter
  views: ViewFilter
}

input ProjectUpdateInput {
  createdAt: DateTime
  index: Int
  languages: LanguageUpdateManyWithoutProjectsInput
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutProjectsInput
  views: ViewUpdateManyWithoutProjectInput
}

input ProjectUpdateManyDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
}

input ProjectUpdateManyWithoutLanguagesInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutLanguagesInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutLanguagesInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutLanguagesInput!]
}

input ProjectUpdateManyWithoutUsersInput {
  connect: [ProjectWhereUniqueInput!]
  create: [ProjectCreateWithoutUsersInput!]
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutUsersInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutUsersInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  data: ProjectUpdateManyDataInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateOneRequiredWithoutViewsInput {
  connect: ProjectWhereUniqueInput
  create: ProjectCreateWithoutViewsInput
  update: ProjectUpdateWithoutViewsDataInput
  upsert: ProjectUpsertWithoutViewsInput
}

input ProjectUpdateWithoutLanguagesDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutProjectsInput
  views: ViewUpdateManyWithoutProjectInput
}

input ProjectUpdateWithoutUsersDataInput {
  createdAt: DateTime
  index: Int
  languages: LanguageUpdateManyWithoutProjectsInput
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  views: ViewUpdateManyWithoutProjectInput
}

input ProjectUpdateWithoutViewsDataInput {
  createdAt: DateTime
  index: Int
  languages: LanguageUpdateManyWithoutProjectsInput
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
  users: UserUpdateManyWithoutProjectsInput
}

input ProjectUpdateWithWhereUniqueWithoutLanguagesInput {
  data: ProjectUpdateWithoutLanguagesDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithWhereUniqueWithoutUsersInput {
  data: ProjectUpdateWithoutUsersDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutViewsInput {
  create: ProjectCreateWithoutViewsInput!
  update: ProjectUpdateWithoutViewsDataInput!
}

input ProjectUpsertWithWhereUniqueWithoutLanguagesInput {
  create: ProjectCreateWithoutLanguagesInput!
  update: ProjectUpdateWithoutLanguagesDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithWhereUniqueWithoutUsersInput {
  create: ProjectCreateWithoutUsersInput!
  update: ProjectUpdateWithoutUsersDataInput!
  where: ProjectWhereUniqueInput!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  languages: LanguageFilter
  name: StringFilter
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  screenshot: NullableStringFilter
  slug: StringFilter
  updatedAt: DateTimeFilter
  users: UserFilter
  views: ViewFilter
}

input ProjectWhereUniqueInput {
  id: Int
}

type Query {
  language(where: LanguageWhereUniqueInput!): Language
  languages(after: LanguageWhereUniqueInput, before: LanguageWhereUniqueInput, first: Int, last: Int, where: LanguageWhereInput): [Language!]!
  languagesOnTranslations(after: LanguagesOnTranslationsWhereUniqueInput, before: LanguagesOnTranslationsWhereUniqueInput, first: Int, last: Int): [LanguagesOnTranslations!]!
  project(where: ProjectWhereUniqueInput!): Project
  projects(after: ProjectWhereUniqueInput, before: ProjectWhereUniqueInput, first: Int, last: Int): [Project!]!
  translation(where: TranslationWhereUniqueInput!): Translation
  translations(after: TranslationWhereUniqueInput, before: TranslationWhereUniqueInput, first: Int, last: Int): [Translation!]!
  user(where: UserWhereUniqueInput!): User
  users(after: UserWhereUniqueInput, before: UserWhereUniqueInput, first: Int, last: Int): [User!]!
  view(where: ViewWhereUniqueInput!): View
  views(after: ViewWhereUniqueInput, before: ViewWhereUniqueInput, first: Int, last: Int): [View!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Translation {
  createdAt: DateTime!
  id: Int!
  index: Int!
  key: String!
  label: String
  languages(after: LanguagesOnTranslationsWhereUniqueInput, before: LanguagesOnTranslationsWhereUniqueInput, first: Int, last: Int): [LanguagesOnTranslations!]!
  updatedAt: DateTime!
  view: View!
  x: Float
  y: Float
}

input TranslationCreateInput {
  createdAt: DateTime
  index: Int
  key: String!
  label: String
  languages: LanguagesOnTranslationsCreateManyWithoutTranslationInput
  updatedAt: DateTime
  view: ViewCreateOneWithoutTranslationInput!
  x: Float
  y: Float
}

input TranslationCreateManyWithoutViewInput {
  connect: [TranslationWhereUniqueInput!]
  create: [TranslationCreateWithoutViewInput!]
}

input TranslationCreateOneWithoutLanguagesInput {
  connect: TranslationWhereUniqueInput
  create: TranslationCreateWithoutLanguagesInput
}

input TranslationCreateWithoutLanguagesInput {
  createdAt: DateTime
  index: Int
  key: String!
  label: String
  updatedAt: DateTime
  view: ViewCreateOneWithoutTranslationInput!
  x: Float
  y: Float
}

input TranslationCreateWithoutViewInput {
  createdAt: DateTime
  index: Int
  key: String!
  label: String
  languages: LanguagesOnTranslationsCreateManyWithoutTranslationInput
  updatedAt: DateTime
  x: Float
  y: Float
}

input TranslationFilter {
  every: TranslationWhereInput
  none: TranslationWhereInput
  some: TranslationWhereInput
}

input TranslationIdLanguageIdCompoundUniqueInput {
  languageId: Int!
  translationId: Int!
}

input TranslationScalarWhereInput {
  AND: [TranslationScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  key: StringFilter
  label: NullableStringFilter
  languages: LanguagesOnTranslationsFilter
  NOT: [TranslationScalarWhereInput!]
  OR: [TranslationScalarWhereInput!]
  updatedAt: DateTimeFilter
  viewId: IntFilter
  x: NullableFloatFilter
  y: NullableFloatFilter
}

input TranslationUpdateInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  languages: LanguagesOnTranslationsUpdateManyWithoutTranslationInput
  updatedAt: DateTime
  view: ViewUpdateOneRequiredWithoutTranslationInput
  x: Float
  y: Float
}

input TranslationUpdateManyDataInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  updatedAt: DateTime
  x: Float
  y: Float
}

input TranslationUpdateManyWithoutViewInput {
  connect: [TranslationWhereUniqueInput!]
  create: [TranslationCreateWithoutViewInput!]
  delete: [TranslationWhereUniqueInput!]
  deleteMany: [TranslationScalarWhereInput!]
  disconnect: [TranslationWhereUniqueInput!]
  set: [TranslationWhereUniqueInput!]
  update: [TranslationUpdateWithWhereUniqueWithoutViewInput!]
  updateMany: [TranslationUpdateManyWithWhereNestedInput!]
  upsert: [TranslationUpsertWithWhereUniqueWithoutViewInput!]
}

input TranslationUpdateManyWithWhereNestedInput {
  data: TranslationUpdateManyDataInput!
  where: TranslationScalarWhereInput!
}

input TranslationUpdateOneRequiredWithoutLanguagesInput {
  connect: TranslationWhereUniqueInput
  create: TranslationCreateWithoutLanguagesInput
  update: TranslationUpdateWithoutLanguagesDataInput
  upsert: TranslationUpsertWithoutLanguagesInput
}

input TranslationUpdateWithoutLanguagesDataInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  updatedAt: DateTime
  view: ViewUpdateOneRequiredWithoutTranslationInput
  x: Float
  y: Float
}

input TranslationUpdateWithoutViewDataInput {
  createdAt: DateTime
  index: Int
  key: String
  label: String
  languages: LanguagesOnTranslationsUpdateManyWithoutTranslationInput
  updatedAt: DateTime
  x: Float
  y: Float
}

input TranslationUpdateWithWhereUniqueWithoutViewInput {
  data: TranslationUpdateWithoutViewDataInput!
  where: TranslationWhereUniqueInput!
}

input TranslationUpsertWithoutLanguagesInput {
  create: TranslationCreateWithoutLanguagesInput!
  update: TranslationUpdateWithoutLanguagesDataInput!
}

input TranslationUpsertWithWhereUniqueWithoutViewInput {
  create: TranslationCreateWithoutViewInput!
  update: TranslationUpdateWithoutViewDataInput!
  where: TranslationWhereUniqueInput!
}

input TranslationWhereInput {
  AND: [TranslationWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  key: StringFilter
  label: NullableStringFilter
  languages: LanguagesOnTranslationsFilter
  NOT: [TranslationWhereInput!]
  OR: [TranslationWhereInput!]
  updatedAt: DateTimeFilter
  view: ViewWhereInput
  viewId: IntFilter
  x: NullableFloatFilter
  y: NullableFloatFilter
}

input TranslationWhereUniqueInput {
  id: Int
}

type User {
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  projects(after: ProjectWhereUniqueInput, before: ProjectWhereUniqueInput, first: Int, last: Int): [Project!]!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  projects: ProjectCreateManyWithoutUsersInput
  updatedAt: DateTime
}

input UserCreateManyWithoutProjectsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutProjectsInput!]
}

input UserCreateWithoutProjectsInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  updatedAt: DateTime
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  projects: ProjectFilter
  updatedAt: DateTimeFilter
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  projects: ProjectUpdateManyWithoutUsersInput
  updatedAt: DateTime
}

input UserUpdateManyDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpdateManyWithoutProjectsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutProjectsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutProjectsInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutProjectsInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateWithoutProjectsDataInput {
  createdAt: DateTime
  email: String
  name: String
  password: String
  updatedAt: DateTime
}

input UserUpdateWithWhereUniqueWithoutProjectsInput {
  data: UserUpdateWithoutProjectsDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithWhereUniqueWithoutProjectsInput {
  create: UserCreateWithoutProjectsInput!
  update: UserUpdateWithoutProjectsDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  projects: ProjectFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}

type View {
  createdAt: DateTime!
  id: Int!
  index: Int!
  name: String!
  project: Project!
  screenshot: String
  slug: String!
  translation(after: TranslationWhereUniqueInput, before: TranslationWhereUniqueInput, first: Int, last: Int): [Translation!]!
  updatedAt: DateTime!
}

input ViewCreateInput {
  createdAt: DateTime
  index: Int
  name: String!
  project: ProjectCreateOneWithoutViewsInput!
  screenshot: String
  slug: String!
  translation: TranslationCreateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewCreateManyWithoutProjectInput {
  connect: [ViewWhereUniqueInput!]
  create: [ViewCreateWithoutProjectInput!]
}

input ViewCreateOneWithoutTranslationInput {
  connect: ViewWhereUniqueInput
  create: ViewCreateWithoutTranslationInput
}

input ViewCreateWithoutProjectInput {
  createdAt: DateTime
  index: Int
  name: String!
  screenshot: String
  slug: String!
  translation: TranslationCreateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewCreateWithoutTranslationInput {
  createdAt: DateTime
  index: Int
  name: String!
  project: ProjectCreateOneWithoutViewsInput!
  screenshot: String
  slug: String!
  updatedAt: DateTime
}

input ViewFilter {
  every: ViewWhereInput
  none: ViewWhereInput
  some: ViewWhereInput
}

input ViewScalarWhereInput {
  AND: [ViewScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  name: StringFilter
  NOT: [ViewScalarWhereInput!]
  OR: [ViewScalarWhereInput!]
  projectId: IntFilter
  screenshot: NullableStringFilter
  slug: StringFilter
  translation: TranslationFilter
  updatedAt: DateTimeFilter
}

input ViewUpdateInput {
  createdAt: DateTime
  index: Int
  name: String
  project: ProjectUpdateOneRequiredWithoutViewsInput
  screenshot: String
  slug: String
  translation: TranslationUpdateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewUpdateManyDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  updatedAt: DateTime
}

input ViewUpdateManyWithoutProjectInput {
  connect: [ViewWhereUniqueInput!]
  create: [ViewCreateWithoutProjectInput!]
  delete: [ViewWhereUniqueInput!]
  deleteMany: [ViewScalarWhereInput!]
  disconnect: [ViewWhereUniqueInput!]
  set: [ViewWhereUniqueInput!]
  update: [ViewUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [ViewUpdateManyWithWhereNestedInput!]
  upsert: [ViewUpsertWithWhereUniqueWithoutProjectInput!]
}

input ViewUpdateManyWithWhereNestedInput {
  data: ViewUpdateManyDataInput!
  where: ViewScalarWhereInput!
}

input ViewUpdateOneRequiredWithoutTranslationInput {
  connect: ViewWhereUniqueInput
  create: ViewCreateWithoutTranslationInput
  update: ViewUpdateWithoutTranslationDataInput
  upsert: ViewUpsertWithoutTranslationInput
}

input ViewUpdateWithoutProjectDataInput {
  createdAt: DateTime
  index: Int
  name: String
  screenshot: String
  slug: String
  translation: TranslationUpdateManyWithoutViewInput
  updatedAt: DateTime
}

input ViewUpdateWithoutTranslationDataInput {
  createdAt: DateTime
  index: Int
  name: String
  project: ProjectUpdateOneRequiredWithoutViewsInput
  screenshot: String
  slug: String
  updatedAt: DateTime
}

input ViewUpdateWithWhereUniqueWithoutProjectInput {
  data: ViewUpdateWithoutProjectDataInput!
  where: ViewWhereUniqueInput!
}

input ViewUpsertWithoutTranslationInput {
  create: ViewCreateWithoutTranslationInput!
  update: ViewUpdateWithoutTranslationDataInput!
}

input ViewUpsertWithWhereUniqueWithoutProjectInput {
  create: ViewCreateWithoutProjectInput!
  update: ViewUpdateWithoutProjectDataInput!
  where: ViewWhereUniqueInput!
}

input ViewWhereInput {
  AND: [ViewWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  index: IntFilter
  name: StringFilter
  NOT: [ViewWhereInput!]
  OR: [ViewWhereInput!]
  project: ProjectWhereInput
  projectId: IntFilter
  screenshot: NullableStringFilter
  slug: StringFilter
  translation: TranslationFilter
  updatedAt: DateTimeFilter
}

input ViewWhereUniqueInput {
  id: Int
}
